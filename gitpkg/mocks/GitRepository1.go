// Code generated by mockery v2.45.0. DO NOT EDIT.

package mocks

import (
	gitpkg "qgit/gitpkg"
	fs "io/fs"
	"fmt"
	
	mock "github.com/stretchr/testify/mock"
)

// GitRepository1 is an autogenerated mock type for the GitRepository1 type
type GitRepository1 struct {
	mock.Mock
}

// CheckRemoteRef provides a mock function with given fields: ref
func (_m *GitRepository1) CheckRemoteRef(ref string) (bool, bool, bool) {
	ret := _m.Called(ref)

	if len(ret) == 0 {
		panic("no return value specified for CheckRemoteRef")
	}

	var r0 bool
	var r1 bool
	var r2 bool
	if rf, ok := ret.Get(0).(func(string) (bool, bool, bool)); ok {
		return rf(ref)
	}
	if rf, ok := ret.Get(0).(func(string) bool); ok {
		r0 = rf(ref)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string) bool); ok {
		r1 = rf(ref)
	} else {
		r1 = ret.Get(1).(bool)
	}

	if rf, ok := ret.Get(2).(func(string) bool); ok {
		r2 = rf(ref)
	} else {
		r2 = ret.Get(2).(bool)
	}

	return r0, r1, r2
}

// Checkout provides a mock function with given fields: ref
func (gr *GitRepository1) Checkout(ref string) error {
	isBranch, isTag, isCommitHash := gr.CheckRemoteRef(ref)

	switch {
	case isBranch:
		fmt.Println("Checking out branch:", ref)
		return gr.CheckoutBranch(ref)
	case isTag:
		fmt.Println("Checking out tag:", ref)
		return gr.CheckoutTag(ref)
	case isCommitHash:
		fmt.Println("Checking out commit hash:", ref)
		return gr.CheckoutHash(ref)
	default:
		return fmt.Errorf("reference not found: %s", ref)
	}
}

// CheckoutBranch provides a mock function with given fields: branch
func (_m *GitRepository1) CheckoutBranch(branch string) error {
	ret := _m.Called(branch)

	if len(ret) == 0 {
		panic("no return value specified for CheckoutBranch")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string) error); ok {
		r0 = rf(branch)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// CheckoutHash provides a mock function with given fields: hash
func (_m *GitRepository1) CheckoutHash(hash string) error {
	ret := _m.Called(hash)

	if len(ret) == 0 {
		panic("no return value specified for CheckoutHash")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string) error); ok {
		r0 = rf(hash)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// CheckoutTag provides a mock function with given fields: tag
func (_m *GitRepository1) CheckoutTag(tag string) error {
	ret := _m.Called(tag)

	if len(ret) == 0 {
		panic("no return value specified for CheckoutTag")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string) error); ok {
		r0 = rf(tag)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Fetch provides a mock function with given fields: refSpecStr
func (_m *GitRepository1) Fetch(refSpecStr string) error {
	ret := _m.Called(refSpecStr)

	if len(ret) == 0 {
		panic("no return value specified for Fetch")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string) error); ok {
		r0 = rf(refSpecStr)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Head provides a mock function with given fields:
func (_m *GitRepository1) Head() (gitpkg.QReference, error) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Head")
	}

	var r0 gitpkg.QReference
	var r1 error
	if rf, ok := ret.Get(0).(func() (gitpkg.QReference, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() gitpkg.QReference); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(gitpkg.QReference)
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PlainClone provides a mock function with given fields: o
func (_m *GitRepository1) PlainClone(o gitpkg.QgitOptions) error {
	ret := _m.Called(o)

	if len(ret) == 0 {
		panic("no return value specified for PlainClone")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(gitpkg.QgitOptions) error); ok {
		r0 = rf(o)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// PlainOpen provides a mock function with given fields: o
func (_m *GitRepository1) PlainOpen(o gitpkg.QgitOptions) error {
	ret := _m.Called(o)

	if len(ret) == 0 {
		panic("no return value specified for PlainOpen")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(gitpkg.QgitOptions) error); ok {
		r0 = rf(o)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Stat provides a mock function with given fields: path
func (_m *GitRepository1) Stat(path string) (fs.FileInfo, error) {
	ret := _m.Called(path)

	if len(ret) == 0 {
		panic("no return value specified for Stat")
	}

	var r0 fs.FileInfo
	var r1 error
	if rf, ok := ret.Get(0).(func(string) (fs.FileInfo, error)); ok {
		return rf(path)
	}
	if rf, ok := ret.Get(0).(func(string) fs.FileInfo); ok {
		r0 = rf(path)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(fs.FileInfo)
		}
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(path)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Worktree provides a mock function with given fields:
func (_m *GitRepository1) Worktree() (gitpkg.GitWorktree, error) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Worktree")
	}

	var r0 gitpkg.GitWorktree
	var r1 error
	if rf, ok := ret.Get(0).(func() (gitpkg.GitWorktree, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() gitpkg.GitWorktree); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(gitpkg.GitWorktree)
		}
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewGitRepository1 creates a new instance of GitRepository1. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewGitRepository1(t interface {
	mock.TestingT
	Cleanup(func())
}) *GitRepository1 {
	mock := &GitRepository1{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
